package euler

import scala.collection.mutable._

import scala.math._
import util.Prime
import java.io._
import util.Time._
import scala.util.control.Breaks._

// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
// Triangle   P3,n=n(n+1)/2   1, 3, 6, 10, 15, ...
// Square   P4,n=n2   1, 4, 9, 16, 25, ...
// Pentagonal   P5,n=n(3n−1)/2    1, 5, 12, 22, 35, ...
// Hexagonal    P6,n=n(2n−1)    1, 6, 15, 28, 45, ...
// Heptagonal   P7,n=n(5n−3)/2    1, 7, 18, 34, 55, ...
// Octagonal    P8,n=n(3n−2)    1, 8, 21, 40, 65, ...
// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
// The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
// Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
// This is the only set of 4-digit numbers with this property.
// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
// triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
object Problem61 {
  
  def linked(v: Int, n: Int) = v % 100 == n / 100
  
  def find(allLists: Vector[Vector[Int]]): Vector[Int] = {
    val startingList = allLists(0)
    val remainingLists = allLists.drop(1)
    val chain = Vector[Int]()
    for (startingVal <- startingList) {
      val result = findChain(startingVal, startingVal, startingList, remainingLists, chain)
      if (result._1) {
       return startingVal +: result._2 
      }
    }
    Vector()
  }
  
  def findChain(startingVal: Int,
                matchVal: Int,
                startingList: Vector[Int],
                candidates: Vector[Vector[Int]],
                chain: Vector[Int]): Tuple2[Boolean, Vector[Int]] = {
    if (candidates.size == 0 && linked(matchVal, startingVal)) {
       return (true, chain) // found the full chain     
    }
    for (c <- candidates) {
      // calculate next candidates set
      var remainingCandidates = candidates filter {_ != c}
      for (v <- c) {
        if (linked(matchVal, v)) {
          val nextChain = chain :+ v
          val result = findChain(startingVal, v, c, remainingCandidates, nextChain)
          if (result._1) {
            return result
          }
        }
      }
    }
    (false, Vector())
  }
  
  def main(args: Array[String]) = {
    time {
      val triangleList = (1 to 200) map {n => n*(n+1)/2} dropWhile {_ < 1000} takeWhile {_ < 10000} toVector
      val squareList = (1 to 100) map {n => n*n} dropWhile {_ < 1000} takeWhile {_ < 10000} toVector
      val pentList = (1 to 100) map {n => n*(3*n-1)/2} dropWhile {_ < 1000} takeWhile {_ < 10000} toVector
      val hexList = (1 to 100) map {n => n*(2*n-1)} dropWhile {_ < 1000} takeWhile {_ < 10000} toVector
      val heptList = (1 to 100) map {n => n*(5*n-3)/2} dropWhile {_ < 1000} takeWhile {_ < 10000} toVector
      val octList = (1 to 100) map {n => n*(3*n-2)} dropWhile {_ < 1000} takeWhile {_ < 10000} toVector
      val allLists = Vector(octList, heptList, hexList, pentList, squareList, triangleList)
      println(triangleList)
      println(squareList)
      println(pentList)
      val chain = find(allLists)
      println("Problem 61: " + chain.sum)
    }
  }
}