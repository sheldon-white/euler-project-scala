package euler

import scala.collection.mutable._
import scala.math._
import BigInt._
import java.io._
import util.Time._

// Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
//
// 2^2=4, 2^3=8, 2^4=16, 2^5=32
// 3^2=9, 3^3=27, 3^4=81, 3^5=243
// 4^2=16, 4^3=64, 4^4=256, 4^5=1024
// 5^2=25, 5^3=125, 5^4=625, 5^5=3125
// If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
//
// How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
object Problem29 {
  val smallPrimes = List(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,51,53,59,61,67,71,73,79,83,89,97)
  
  def factorization(num: Int): HashMap[Int, Int] = {
    val factorization = HashMap[Int, Int]()
    var n = num
    for (prime <- smallPrimes) {
      var ctr = 0
      while (n % prime == 0) {
        ctr += 1
        n = n / prime
      }
      if (ctr > 0) {
        factorization(prime) = ctr
      }
    }
    factorization
  }
  
  def allFactorizations = (2 to 100) map {factorization}
  
  def main(args: Array[String]) = {
    time {
      var allPowers = HashSet[String]()
      for (pow <- 2 to 100) {
        for (factorization <- allFactorizations) {
          val numToPow = (for ((k,v) <- factorization) yield (k, pow * v)).toMap
          allPowers += numToPow.toString
        }
      }
      println("Problem 29: " + allPowers.size)
    }
  }
 }